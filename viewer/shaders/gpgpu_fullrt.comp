#version 430 core

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;

uniform bool transparent;

float alpha = (200 - shininess) / 200;

#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001
#define M_PI 3.1415926535897932384626433832795

// Struct and variables for color computing
struct info_rebound
{
    vec4 hit_point;
    vec4 normal;
    vec4 origin;
    vec4 dir;
    vec4 color;
};

const int nb_rebound_max = 2;
float ka = 0.2;
float kd = 0.5;
float ks = 0.01;

float outCompute(vec3 tmin, vec3 tmax) {
    return min(max(max(tmin.x, tmin.y), tmin.z), max(max(tmax.x, tmax.y), tmax.z));
}

float inCompute(vec3 tmin, vec3 tmax) {
    return max(min(min(tmin.x, tmin.y), tmin.z), min(min(tmax.x, tmax.y), tmax.z));
}

struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

// Usefull functions to compute light
float G(float cos_theta)
{
    float cos_theta_carre = pow(cos_theta, 2.);
    float tan_theta_carre = (1 - cos_theta_carre) / cos_theta_carre;
    return 2. / (1. + pow(1 + pow(alpha, 2) * tan_theta_carre, 0.5));
}

float D(float cos_theta)
{
    float xi = 1;

    if (cos_theta <= 0)
    {
        return 0;
    }

    float cos_theta_carre = pow(cos_theta, 2.);
    float tan_theta_carre = (1 - cos_theta_carre) / cos_theta_carre;
    
    return xi / (M_PI * pow(cos_theta, 4)) * pow(alpha, 2) / pow(pow(alpha, 2) + tan_theta_carre, 2);
}

float F(float cos_theta, float current_eta)
{
    float sin_theta_carre = 1. - pow(cos_theta, 2.);
    if (pow(current_eta, 2) < sin_theta_carre)
    {
        return 1; // Reflexion totale
    }
    float c_i = pow(pow(current_eta, 2) - sin_theta_carre, 0.5);
    float F_s = pow(abs((cos_theta - c_i) / (cos_theta + c_i)), 2);
    float F_p = pow(abs((pow(current_eta, 2) * cos_theta - c_i) / (pow(current_eta, 2) * cos_theta + c_i)), 2);
    return (F_s + F_p) / 2;
}

bool intersectBoundingBox(vec4 origin, vec4 dir) {
    vec3 tmin = (bbmin.xyz - origin.xyz) / dir.xyz;
    vec3 tmax = (bbmax.xyz - origin.xyz) / dir.xyz;
    return outCompute(tmin, tmax) > inCompute(tmin, tmax);
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist) {
    vec3 v0 = vertices[indices[ptr]].xyz;
    vec3 v1 = vertices[indices[ptr + 1]].xyz;
    vec3 v2 = vertices[indices[ptr + 2]].xyz;

    vec3 e1 = normalize(v1 - v0);
    vec3 e2 = normalize(v2 - v0);
    vec3 t = normalize(origin.xyz - v0);

    vec3 u = normalize(dir.xyz);
    vec3 p = cross(u, e2);
    vec3 q = cross(t, e1);

    float cst = dot(p, e1);

    if (cst == 0) {
        return false;
    }

    vec3 sol = (1/cst) * vec3(dot(q, e2), dot(p, t), dot(q, u));
    float lambda = sol[0];
    float alpha = sol[1];
    float beta = sol[2];
    if ((lambda <= EPS) || (alpha<-EPS || alpha>1+EPS) || (beta<-EPS || beta>1+EPS) || ((1 - alpha - beta)<-EPS || (1-alpha-beta)>1+EPS)) {
        return false;
    }
    dist[0] = alpha;
    dist[1] = beta;
    dist[2] = 1 - alpha - beta;
    dist[3] = lambda;
    
    if (transparent){
        return false;
    }
    return true;
}

vec4 interpolateNormal(hitinfo_t h)
{
	// TODO
    if (h.hit_vptr != -1) {
        vec4 n0 = normals[indices[h.hit_vptr]];
        vec4 n1 = normals[indices[h.hit_vptr + 1]];
        vec4 n2 = normals[indices[h.hit_vptr + 2]];
        return normalize(n0 * h.t.x + n1 * h.t.y + n2 * h.t.z);
    }
    return vec4(1);
}

vec4 interpolateColor(hitinfo_t h)
{
	// TODO
    if (h.hit_vptr != -1) {
        vec4 c0 = colors[indices[h.hit_vptr]];
        vec4 c1 = colors[indices[h.hit_vptr + 1]];
        vec4 c2 = colors[indices[h.hit_vptr + 2]];
        return c0 * h.t.x + c1 * h.t.y + c2 * h.t.z;
    }
	return vec4(1);
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
    int test = 0;
	h.t.w = -1;
    h.hit_vptr = -1;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length()/50; j += 3) {
			if(intersectTriangle(origin, dir, j, dist)) {
                hit = true;
                if (h.t.w == -1 || dist.w < h.t.w) {
                    h.hit_vptr = j;
                    h.t = dist;
                }
			}
		}
	}

    return hit;

}

const int MAX_TRACE = 1;

vec4 phongModel(vec4 u, vec4 normal, vec4 dir, vec4 vertColor, float I) {
    vec4 Ca = ka * vertColor * I;
    
    vec4 halfVec = normalize(dir + u);
    float cos_theta = dot(halfVec, dir);
    float fresnel_coeff = F(cos_theta, eta);

    // Diffuse lighting
    vec4 Cd = kd * vertColor * max(dot(normal, u), 0) * I;

    // Specular lighting
    float F_theta = fresnel_coeff;
    vec4 Cs = ks * F_theta * I * vertColor * pow(max(dot(normal, halfVec), 0), shininess);
    if (cos_theta > 1 )
    {
        Cs = vec4(255,0,0,1);
    }

    return Ca + Cd + Cs;
}

vec4 trace(vec4 origin, vec4 dir)
{
	hitinfo_t h;
    info_rebound rebounds_data[nb_rebound_max]; 
    vec4 current_origin = vec4(origin.xyzw);
    vec4 current_dir = vec4(dir.xyzw);
    vec4 color = vec4(0,0,0,1);

    int nb_rebound = 0;

    while (nb_rebound < nb_rebound_max && isIntersected(current_origin, current_dir, h))
    {
        // Initialize data of the point hit
        rebounds_data[nb_rebound].origin = current_origin;

        current_origin += h.t.w * current_dir;
        rebounds_data[nb_rebound].hit_point = current_origin;
        
        rebounds_data[nb_rebound].normal = interpolateNormal(h);
        rebounds_data[nb_rebound].dir = reflect(current_dir, rebounds_data[nb_rebound].normal);
        rebounds_data[nb_rebound].color = interpolateColor(h);

        current_dir = vec4(rebounds_data[nb_rebound].dir);

        nb_rebound ++;
    }

    // Compute color
    // for (int i = nb_rebound-1; i >= 0; --i)
    // {
    //     vec4 point = rebounds_data[i].hit_point; // Hitting point
    //     vec4 normal = rebounds_data[nb_rebound].normal; // Normal of point of intersection
    //     vec4 origin = rebounds_data[nb_rebound].origin;
    //     vec4 dir = rebounds_data[nb_rebound].dir;
    //     vec4 vert_color = rebounds_data[nb_rebound].color;

    //     color += phongModel(normalize(vec4(lightPosition, 1) - point), normalize(normal), normalize(origin - point), vert_color, lightIntensity);
    // }
    return color;
}

layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5)); 
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates. 
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);

    imageStore(framebuffer, pix, color);
}
